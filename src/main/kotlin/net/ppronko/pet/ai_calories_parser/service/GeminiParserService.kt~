package net.ppronko.pet.ai_calories_parser.service

import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpEntity
import org.springframework.http.HttpHeaders
import org.springframework.http.MediaType
import org.springframework.stereotype.Service
import org.springframework.web.client.RestTemplate
import net.ppronko.pet.ai_calories_parser.data.*

@Service
class GeminiParserService(
    private val restTemplate: RestTemplate,
    @Value("\${gemini.api.key}") private val apiKey: String
): GeminiService<ParsedMealResponse> {
    private val logger = LoggerFactory.getLogger(javaClass)
    private val objectMapper = jacksonObjectMapper()

    override fun parse(description: String): ParsedMealResponse {
        val geminiUrl = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=$apiKey"

        val prompt = createPrompt(description)
        val requestBody = GeminiRequest(listOf(Content(listOf(Part(text = prompt)))))

        val headers = HttpHeaders()
        headers.contentType = MediaType.APPLICATION_JSON

        val httpEntity = HttpEntity(requestBody, headers)

        logger.info("Sending request to Gemini API...")
        val responseEntity = restTemplate.postForEntity(geminiUrl, httpEntity, GeminiResponse::class.java)

        if (!responseEntity.statusCode.is2xxSuccessful || responseEntity.body == null) {
            logger.error("Error from Gemini API: ${responseEntity.body?.error?.message}")
            throw RuntimeException("Failed to get response from Gemini API.")
        }

        val responseText = responseEntity.body?.candidates?.firstOrNull()?.content?.parts?.firstOrNull()?.text
            ?: throw RuntimeException("No content in Gemini API response.")

        logger.info("Received raw response: $responseText")

        val cleanJson = responseText.replace("```json", "").replace("```", "").trim()

        return try {
            objectMapper.readValue(cleanJson, ParsedMealResponse::class.java)
        } catch (e: Exception) {
            logger.error("Failed to parse JSON from Gemini response: $cleanJson", e)
            throw RuntimeException("Failed to parse JSON from Gemini response.", e)
        }
    }

    override fun createPrompt(description: String): String {
        return """
        Ты — эксперт-диетолог и программист. Твоя задача — проанализировать текстовое описание приема пищи на русском языке и вернуть ТОЛЬКО JSON-объект строго определенной структуры.
        Не добавляй никакого другого текста, комментариев или markdown-форматирования (вроде ```json) вне самого JSON-объекта. Только чистый JSON.

        Структура JSON должна быть следующей:
        {
          "mealName": "краткое название приема пищи на русском",
          "items": [
            {
              "name": "название продукта на русском",
              "weightGrams": примерный_вес_в_граммах,
              "calories": калории_для_этого_веса,
              "protein": белки_в_граммах_для_этого_веса,
              "fats": жиры_в_граммах_для_этого_веса,
              "carbs": углеводы_в_граммах_для_этого_веса
            }
          ],
          "summary": {
            "totalCalories": общие_калории_за_весь_прием_пищи,
            "totalProtein": общие_белки_за_весь_прием_пищи,
            "totalFats": общие_жиры_за_весь_прием_пищи,
            "totalCarbs": общие_углеводы_за_весь_прием_пищи
          }
        }

        Придумай краткое, но емкое название для всего приема пищи в поле "mealName".
        Используй средние значения КБЖУ для продуктов. Оценивай вес максимально реалистично. Например: "чашка кофе" — 250г, "стакан молока" — 200г, "столовая ложка сахара" — 25г, "кусок хлеба" — 30г, "одно яйцо" — 55г.
        Обязательно просуммируй КБЖУ всех продуктов в секции "summary".

        Вот текст для анализа: "$description"
    """.trimIndent()
    }
}